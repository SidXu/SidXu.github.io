<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android 跨进程操作Sqlite数据库]]></title>
    <url>%2F2019%2F01%2F29%2FAndroid-%E8%B7%A8%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9CSqlite%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[最近开发了一个日志收集和上传的功能，主要包括运行时日志和崩溃日志两个类型。 崩溃日志：崩溃日志的收集要容易点，当捕获到崩溃信息后，直接在本地生成一个文件，将崩溃信息写入文件中，等到下一次上传 运行时日志运行时日志就是我们通过Log往控制台打印出来的调试信息，因此它的收集就没有崩溃日志那么简单了，我们通过自定义的LogUtil工具类将我们打印的日志信息重定向到控制类里，然后在保存到数据库中，当上传时从数据中读取日志信息生成文件，再跟崩溃日志一样上传 问题由于我们的应用内是多进程的，有一个主进程和一个服务进程，由于服务进程具有保活功能，因而日志的上传一般放在服务进程中，但是连个进程都会打印运行时日志，所以日志收集的功能两个进程都需要有的，日志信息都需要保存到一个数据库中，因此就涉及到了跨进程访问数据库。 解决方案如果我们不加措施的让两个进程同时访问数据库，对于读操作来说是没有什么问题的，但是对于写操作就会有问题了。SQLite的锁机制允许多个读，但是一次只允许一个写。写锁会在写期间排他地锁定数据库，其他进程在此期间不能访问数据库。所以说当两个进程同时往一个数据库里写时系统就会抛出异常，即使catch异常，也会导致数据的丢失。经过一番研究之后，决定通过ContentProvicder的方式操作数据库，成功的解决了跨进程操作数据库的问题 Android中ContentProvider组件详解 Android四大组件–ContentProvider详解]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
