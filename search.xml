<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Flutter实现可折叠标题栏]]></title>
    <url>%2F2019%2F06%2F23%2Fflutter-animation-header%2F</url>
    <content type="text"><![CDATA[Flutter实现可折叠标题栏先看效果图： 实现方案：在ScrollView里面添加两个头布局（展开布局 + 收缩布局），展开布局开始显示，收缩布局开始隐藏。监听页面滑动，当滑动到指定位置时，展开布局隐藏，收缩布局显示。 具体代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177import 'package:flutter/material.dart';import 'search.dart';class HomePage extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; // TODO: implement createState return _HomePage(); &#125;&#125;class _HomePage extends State&lt;HomePage&gt; &#123; var _showNarrow = false; var _oldShowState = false; var _scrollController = ScrollController(); bool _onNotification(ScrollNotification notification) &#123; bool show = _scrollController.offset &gt; 100; if (show != _oldShowState) &#123; _oldShowState = show; setState(() &#123; _showNarrow = show; &#125;); &#125; return true; &#125; void _functionTap(int index) &#123; Navigator.push( context, new MaterialPageRoute( builder: (context) =&gt; new SearchPage( type: index, )), ); &#125; @override Widget build(BuildContext context) &#123; // TODO: implement build return Scaffold( body: Stack( children: &lt;Widget&gt;[ NotificationListener( onNotification: _onNotification, child: CustomScrollView( slivers: &lt;Widget&gt;[ SliverGrid( gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 1, childAspectRatio: 1.8), delegate: SliverChildBuilderDelegate( (BuildContext context, int index) &#123; return _ExpandWidget(show: !_showNarrow); &#125;, childCount: 1, ), ), SliverFixedExtentList( itemExtent: 50.0, delegate: new SliverChildBuilderDelegate( (context, index) =&gt; new ListTile( title: new Text("List item $index"), subtitle: new Text("this is subtitle"), )), ) ], controller: _scrollController, )), _NarrowWidget( show: _showNarrow, ), ], )); &#125;&#125;// ignore: must_be_immutableclass _ExpandWidget extends StatefulWidget &#123; var show = true; _ExpandWidget(&#123;this.show&#125;); @override State&lt;StatefulWidget&gt; createState() &#123; // TODO: implement createState return _ExpandWidgetState(); &#125;&#125;class _ExpandWidgetState extends State&lt;_ExpandWidget&gt; &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build if (widget.show) &#123; return Stack( children: &lt;Widget&gt;[ Image.asset('images/bg_home_header1.jpg', fit: BoxFit.fill, height: 100), Positioned( bottom: 15.0, left: 20, right: 20, child: Container( child: Row( children: &lt;Widget&gt;[ Icon(Icons.search), Text("请输入关键字查询"), ], ), decoration: new BoxDecoration( color: Color(0xFFFFFFFF), borderRadius: new BorderRadius.circular((5.0)), ), padding: EdgeInsets.all(8.0), ), ), ], fit: StackFit.expand, alignment: Alignment.bottomCenter, ); &#125; else &#123; return Container(); &#125; &#125;&#125;// ignore: must_be_immutableclass _NarrowWidget extends StatefulWidget &#123; var show = false; _NarrowWidget(&#123;this.show&#125;); @override State&lt;StatefulWidget&gt; createState() &#123; // TODO: implement createState return _NarrowWidgetState(); &#125;&#125;class _NarrowWidgetState extends State&lt;_NarrowWidget&gt; &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build if (widget.show) &#123; return Stack( children: &lt;Widget&gt;[ Positioned( top: 0.0, left: 0.0, right: 0.0, child: Container( padding: EdgeInsets.fromLTRB(20, 48, 20, 15), color: Color(0xFF52707A), child: Container( child: Row( children: &lt;Widget&gt;[ Icon(Icons.search), Text("请输入关键字查询"), ], ), decoration: new BoxDecoration( color: Color(0xFFFFFFFF), borderRadius: new BorderRadius.circular((5.0)), ), padding: EdgeInsets.all(8.0), ), )), ], fit: StackFit.expand, alignment: Alignment.topCenter, ); &#125; else &#123; return Container(); &#125; &#125;&#125; 本示例仅是提供实现方案，对于代码中写死的一些值，为了更好的UI效果，需要根据具体实现时计算。]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>客户端</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[客户端埋点方案介绍]]></title>
    <url>%2F2019%2F01%2F29%2Fclient-track-introduce%2F</url>
    <content type="text"><![CDATA[一、概念构建一个数据平台，大体上包括数据采集、数据上报、数据存储、数据计算以及数据可视化展示等几个重要的环节。其中，数据采集与上报是整个流程中重要的一环，只有确保前端数据生产的全面、准确、及时，最终产生的数据结果才是可靠的、有价值的。 为了解决前端埋点的准确性、及时性、开发效率等问题，业内各家公司从不同角度，提出了多种技术方案，这些方案大体上可以归为三类： 1、代码埋点：在需要埋点的节点上，手动调用埋点方法，实现埋点数据的获取； 2、可视化埋点：通过可视化的方式配置采集节点并生成配置文件，客户端解析配置文件，在需要埋点的节点自动添加埋点代码，并上报埋点数据； 3、全埋点：客户端自动采集全部埋点数据并上报，通过可视化的方式查询埋点数据并显示； 二、介绍1、代码埋点在需要埋点的节点调用接口直接上传或者定时上传埋点数据，友盟、百度统计等第三方数据统计服务商大都采用这种方案； 123456789101112button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 业务代码 // ... // 埋点上报 val properties = JSONObject() properties.put("page", "MainActivity") properties.put("type", "围棋") TrackerManager.instance.commonTracker.onEvent("click", properties) &#125;&#125;); 优点：使用灵活、方便设置自定义业务相关的属性 缺点：埋点成本高、更新成本高 2、可视化埋点通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，从而实现所谓的“无痕埋点”，代表方案是已经开源的Mixpanel； View标识为了自动生成事件标识，我们需要获取每个控件自身的ID、类名以及位于所属父组件的Index等特征信息，并逐级向上遍历找到根节点。根节点一般是手动标记的，如果没有标记则默认是视图层次树的顶层节点。最后，将遍历产生的路径上所有节点的特征信息组合在一起，就是这个View的标识。 上面选中View的标识是： ContentFrameLayout/ConstraintLayout[0]/AppCompatButton[0]#btClick 在同一个页面，View标识是唯一的，再加上页面名称和包名，就能够在当前App中唯一确定一个View对象，唯一确定View对象之后，就能够针对当前View进行埋点。 由于需求的改变，同一页面在不同版本肯能会发生变化，因此需要做容错处理。 可视化平台可视化平台一般通过Web页面展示，客户端通过Socket与Web进行连接： 客户端打开APP之后，会从服务端拉取包含View标识的配置文件，就可以针对具体View进行埋点了。埋点信息的查询可通过与View标识关联的描述信息进行查询。 优点：开发、维护成本低；可以按需埋点，灵活性好；对业务代码侵入小 缺点：界面的结构发生变化时，圈选的待监测元素可能会失效；支持的控件和事件类型有限；无法灵活地收集到上下文属性 3、全埋点它并不是真正的不需要埋点，而是前端自动采集全部事件并上报埋点数据，在后端数据计算时过滤出有用数据，代表方案是国内的GrowingIO。 基本原理：利用AOP，在预编译阶段实现在不修改源代码的情况下给所有的View点击事件的回调方法内部添加埋点信息。 AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AspectJ AspectJ是一个java实现的AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能，可以这样说AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言，更幸运的是，AspectJ与java程序完全兼容，几乎是无缝关联，因此对于有java编程基础的工程师，上手和使用都非常容易。 下面我们以一个例子，来看一下如何对点击事件进行全埋点的： 1234567@Aspectclass ViewAspectJ &#123; @After("execution(void android.view.View.OnClickListener.onClick(..)) &amp;&amp; args(view)") fun onViewClickAOP(view: View) &#123; TrackerManager.instance.viewTracker.onClick(view) &#125;&#125; 以上代码在编译后就会在工程中所有实现了OnClickListener接口的onClick方法内部插入以上代码，从而对View的点击事件进行全埋点。 数据查询View事件埋点信息的搜集过程中同样会搜集当前View的标识，也通过可视化平台将View标识和事件描述信息进行关联，然后通过查询描述信息就能查询到View事件了，很方便。 优点：开发、维护成本低；可以追溯历史数据；对业务代码侵入小 缺点：高额流量和计算成本；无法灵活收集属性]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>客户端</tag>
        <tag>埋点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 跨进程操作Sqlite数据库]]></title>
    <url>%2F2019%2F01%2F29%2Fandroid-sqilt-multi-process%2F</url>
    <content type="text"><![CDATA[最近开发了一个日志收集和上传的功能，主要包括运行时日志和崩溃日志两个类型。 崩溃日志：崩溃日志的收集要容易点，当捕获到崩溃信息后，直接在本地生成一个文件，将崩溃信息写入文件中，等到下一次上传 运行时日志运行时日志就是我们通过Log往控制台打印出来的调试信息，因此它的收集就没有崩溃日志那么简单了，我们通过自定义的LogUtil工具类将我们打印的日志信息重定向到控制类里，然后在保存到数据库中，当上传时从数据中读取日志信息生成文件，再跟崩溃日志一样上传 问题由于我们的应用内是多进程的，有一个主进程和一个服务进程，由于服务进程具有保活功能，因而日志的上传一般放在服务进程中，但是连个进程都会打印运行时日志，所以日志收集的功能两个进程都需要有的，日志信息都需要保存到一个数据库中，因此就涉及到了跨进程访问数据库。 解决方案如果我们不加措施的让两个进程同时访问数据库，对于读操作来说是没有什么问题的，但是对于写操作就会有问题了。SQLite的锁机制允许多个读，但是一次只允许一个写。写锁会在写期间排他地锁定数据库，其他进程在此期间不能访问数据库。所以说当两个进程同时往一个数据库里写时系统就会抛出异常，即使catch异常，也会导致数据的丢失。经过一番研究之后，决定通过ContentProvicder的方式操作数据库，成功的解决了跨进程操作数据库的问题 Android中ContentProvider组件详解 Android四大组件–ContentProvider详解]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
